\begin{definition}[\Wrap{content/magyar=Kongruencia,content/english=Congruent}]
  \Wrap{
    content/magyar={Az $a$ és $b$ számok kongruensek modulo $m$ ($m>0$), azaz
      \[ a\equiv b \mod m\text{, amennyiben }m|(a-b).\]},
    content/english={The numbers of $a$ and $b$ are congruent modulo $m$ ($m>0$), i.e.
      \[a\equiv b(\mod m)\text{, if }m|(a-b).\]}
  }
\end{definition}

\Wrap{
  content/magyar={A kongruencia mint reláció reflexív, szimmetrikus és tranzitív is, azaz
    ekvivalenciareláció, így meghatározza az alaphalmaz egy osztályozását.},
  content/english={The congruence as a relation is reflexive, symmetric and transitive, thus
    an equivalence relation, which implies a partitioning of the set its defined over.}
}

\begin{exercise}
  \Wrap{
    content/magyar={Írj programot, amely egy egész számokat tartalmazó halmaz elemeit osztályozza
      modulo $m$, ahol az $m$ a második paraméter.},
    content/english={Write a program that sorting the elements of a given set (first argument)
      modulo $m$ (second argument).}
  }

  \begin{solution}
    \begin{sageexample}
      sage: def residue_sets(S,m):
      ....:     rs = {}
      ....:     for e in S:
      ....:         r = e % m
      ....:         if r in rs.keys():
      ....:             rs[r].add(e)
      ....:         else:
      ....:             rs[r] = set([e])
      ....:     return rs
    \end{sageexample}
  \end{solution}
\end{exercise}

\begin{definition}[\Wrap{content/magyar={Maradékrendszer}, content/english={Residue system}}]
  \Wrap{
    content/magyar={Egész számok esetén a kongruencia mint ekvivalenciareláció által
      meghatározott osztályokat \emph{maradékosztály}nak, míg rendszerüket \emph{maradékrendszer}nek
      nevezzük.},
    content/english={TODO}
  }
\end{definition}

\Wrap{
  content/magyar={Számolás során a maradékosztályokat egy-egy reprezentánsukkal szoktuk jelölni,
    például $m$ esetén gyakori a $0,1,\dots,m-1$ (legkisebb nem negatív reprezentások) vagy
    egész számok esetén a $-\lfloor \frac{m-1}{2}\rfloor,\dots,0,\dots,\lceil\frac{m-1}{2}\rceil$
    (legkisebb abszolút értékű reprezentások) használata.},
  content/english={TODO}
}

\begin{definition}[\Wrap{content/magyar={Redukált maradékrendszer}, content/english={Reduced residue system}}]
  \Wrap{
    content/magyar={Ha a maradékrendszerből elhagyjuk az összes olyan maradékosztályt melyek elemei
      nem relatív prímek a modulushoz, akkor megkapjuk a \emph{redukált maradékrendszer}t.},
    content/english={TODO}
  }
\end{definition}

\begin{definition}[\Wrap{content/magyar={Euler-féle $\varphi$ függvény}}]
  \Wrap{
    content/magyar={A $\varphi:\mathbb{N}\to\mathbb{N}$ függvényt az Euler-féle $\varphi$
      függvénynek nevezzűk, ha $\varphi(m)$ a modulo $m$ redukált maradékrendszerek száma, azaz},
    content/english={TODO}
  }
  \[\varphi(m) = \left|\{k\in\mathbb{Z}:1\le k< m\wedge (k,m)=1\}\right|.\]
\end{definition}

\Wrap{
  content/magyar={Ha $p$ egy prím és $n$ tetszőleges természetes szám, akkor a $\varphi(p^n) =p^n-p^{n-1}$
    könnyen kapható, hiszen pontosan minden $p$-edik maradékosztály tartalmaz $p$-vel osztható
    számokat, a többiben relatív prímek vannak $p$-hez és így $p^n$-hez is. Össztett számokkal való
    számoláshoz elég észrevenni, hogy a $\varphi$ számelméleti függvény multiplikatív, azaz
    relatív prím $a,b$ számokra $\varphi(ab)=\varphi(a)\varphi(b)$.},
  content/english={TODO}
}

\Wrap{
  content/magyar={A $\varphi(n)$ maximuma nyilvánvalóan $n-1$, viszont minimuma közel sem lineáris.},
  content/english={TODO}
}


\begin{sageexample}
  sage: P  = points([(k,euler_phi(k)) for k in range(1,1001)])
\end{sageexample}
\begin{figure}[h]
  \centering
  \sageplot[scale=.6]{P}
  \caption{Euler-féle $\varphi$ függvény értéke 1 és 1000 közötti számokra (\texttt{P}).}
\end{figure}

\begin{exercise}
  \Wrap{
    content/magyar={Írj programotfüggvényt, amely az Euler-féle $\varphi$ függvény értékét
      számolja ki! Ellenőrzéshez használható az \texttt{euler\_phi} parancs.},
    content/english={TODO}
  }

  \begin{solution}
    \begin{sageexample}
    # according to the definition
    sage: def ephi_01(m):
    ....:     p = 0
    ....:     for i in range(1,m):
    ....:         p += gcd(i,m) == 1
    ....:     return p

    #according to the previous note
    sage: def ephi_02(m):
    ....:     p = 1
    ....:     for (a,b) in factor(m):
    ....:         p *= a^(b-1)*(a-1)
    ....:     return p

    \end{sageexample}
  \end{solution}
\end{exercise}

\begin{definition}[\Wrap{content/magyar=Lineáris kongruenciák, content/english=Linear congruence}]
  \Wrap{
    content/magyar={Az $a,b$ egész és $m$ pozitív egész számok esetén az \[ax\equiv b\ (m)\] alakú
      kifejezéseket \emph{lineáris kongruenciának} hívjuk.},
    content/english={TODO}.
  }
\end{definition}

\Wrap{
  content/magyar={A kongruencia és oszthatóság definíciókat használva kapjuk, hogy alkalmas $y$-al},
  content/english={TODO}
}
\[ ax\equiv b\ (m) \Leftrightarrow m|ax-b \Leftrightarrow ax-b = my \Leftrightarrow ax-my=b.\]
\Wrap{
  content/magyar={Ez azt jelenti, hogy egy lineáris kongruencia megoldását megkaphatjuk a
    megfelelő lineáris diofantikus probléma megoldásával. Továbbá},
  content/english={TODO}
}
\begin{itemize}
  \item $(a,m)|b$
    \Wrap{
      content/magyar=szükséges és elégséges feltétel a megoldás létezésére;,
      content/english={TODO}
    }
  \item
    \Wrap{
      content/magyar={$acx\equiv bc\ (cm)$ kongruencia megoldásait megkaphatjuk az
        $ax\equiv b\ (m)$ kongruenca megoldásával;},
      content/english={TODO}
    }
  \item
    \Wrap{
      content/magyar={$(a,m)=1$ esetén mindkét oldalt oszthatjuk $(a,b)$-vel;},
      content/english={TODO}
    }
  \item
    \Wrap{
      content/magyar={$(a,m)=1$ és $(b,m)=c$ esetén a $ax\equiv b\ (m)$ kongruencia megoldásait
        kaphatjuk a $ax\equiv b/c\ (m/c)$ kongruencia megoldásával.},
      content/english={TODO}
    }
\end{itemize}

\begin{exercise}
  \Wrap{
    content/magyar={Írj eljárást lineáris kongruenciák megoldására! Ellenőrzéshez használható a
      \texttt{solve\_mod} parancs.},
    content/english={TODO}
  }
  \begin{solution}
    \begin{sageexample}
    sage: def lin_cong(a,b,m):
    ....:     (d,x,y) = xgcd(a,m)
    ....:     return x % m/d
    \end{sageexample}
  \end{solution}
\end{exercise}

\begin{definition}[\Wrap{content/magyar={Moduláris inverz}, content/english=Modular inverse}]
  \Wrap{
    content/magyar={Az $ax\equiv 1\ (m)$ kongruencia megoldását (ha van) az $a$ szám
      \emph{moduláris inverz}ének nevezzük modulo $m$.},
    content/english={TODO}
  }
\end{definition}

\begin{exercise}
  \Wrap{
    content/magyar={Írj programot, amely kiszámolja első paraméterének moduláris inverzét modulo
      a második paraméter! Ellenőrzéshez használható az \texttt{inverse\_mod} parancs},
    content/english={TODO}
  }

  \begin{solution}
    \begin{sageexample}
    sage: def modinv(a,m):
    ....:     (d,x,y) = xgcd(a,m)
    ....:     if d == 1:
    ....:         return x % m
    ....:     else:
    ....:         return None
    \end{sageexample}
  \end{solution}
\end{exercise}

\begin{definition}[\Wrap{content/magyar=Lineáris kongruencia-rendszer, content/english=System of congruences}]
  \Wrap {
    content/magyar={Legyen $1<n\in\mathbb{N}$, $a_i,b_i\in\mathbb{Z}$ és $1<m_i\in\mathbb{N}$
      ($1\le i\le n$). Ekkor a \[a_ix\equiv b_i\ (m_i) \quad(1\le i\le n)\] kongruenciák összeségét
      \emph{lineáris kongruencia-rendszer}nek hívunk és csak olyan $x$ egész számot tekintünk
      megoldásnak, amely mindegyiknek külön-külön is megoldása.},
    content/english={TODO}
  }
\end{definition}

\Wrap{
  content/magyar={ A kongruenciarendszerek megoldásának megkereséséhez tekintsünk csak két
    kongruenciát és első lépésként oldjuk meg őket külön-külön. Ezek után a feladat az
    \[ x\equiv c_1 (m_1)\text{ és } x\equiv c_2 (m_2), \] kongruenciarendszer megoldásainak
    megtalálása. A fentieknek megfelelően ez azt jelenti, hogy arra alkalmas $y_1$ és $y_2$
    számokkal \[
      \left.
      \begin{array}{ccc}
        m_1|x-c_1 & \Leftrightarrow & x = c_1 + m_1y_1 \\
        m_2|x-c_2 & \Leftrightarrow & x = c_2 + m_2y_2
      \end{array}
      \right\}\Rightarrow c_1-c_2 = m_1y_1 - m_2y_2,
    \]
    ami tetszőleges $c_1, c_2$ esetén csak akkor lehetséges, ha $m_1$ és $m_2$ relatív prímek.
  },
  content/english={TODO}
}

\Wrap{
  content/magyar={Az általános megoldás megtalálásához az előzőek alapján tegyük fel, hogy
    $(m_1, m_2)=1$ és keressük $x$-et $x=x_1+x_2$ alakban, ahol \[
      \begin{array}{ccccccccc}
        x_1 & \equiv & c_1 & (m_1) & \quad & x_1 & \equiv & 0   & (m_2) \\
        x_2 & \equiv & 0   & (m_1) & \quad & x_2 & \equiv & c_2 & (m_2).
      \end{array}
    \]
    Ebből $x_1$-re $m_1|x_1-c_1$ és $m_2|x_1$, azaz $m_1u_1 = x_1-c_1$ és $m_2v_2 = x_1$, tehát
    ha $m_1u+m_2v=1$, akkor \[
      c_1 = m_1u_1-m_2v_1 = m_1uc_1 + m_2vc_1.
    \]Így $x_1=c_1-m_1uc_1 = m_2vc_1$ és hasonlóan $x_2=c_2-m_2vc_2=m_1uc_2$. Ez alapján azt
    kaptuk, hogy a fenti két kongruenciából álló rendszer egy megoldása \[ x = c_1m_2v + c_2m_1u. \]
  },
  content/english={TODO}
}

\Wrap{
  content/magyar={Az nyilvánvaló, hogy az $x+km_1m_2$ is megoldás lesz tetszőleges $k$ egész
    számra, továbbá a megoldás egyértelmű is modulo $m_1m_2$, mivel bármely két megoldás
    különbsége 0 modulo $m_1$ és $m_2$ is, azaz a megoldások közötti különbség a $[m_1,m_2]$
    többszöröse kell hogy legyen. },
  content/english={TODO}
}

\begin{theorem}[\Wrap{content/magyar=Kínai maradéktétel (KMT), content/english=Chinese remainder theorem (CRT)}]
  \Wrap{
    content/magyar={Legyenek $m_1,m_2,\dots,m_n$ egynél nagyobb páronként relatív prím természetes
      számok. Ekkor az $x\equiv c_i\ (m_i)$ $(1\le i\le n)$ kongruenciarendszernek van megoldása
      és a megoldások kongruensek modulo $m_1m_2\dots m_n$, bármely egész $c_1, c_2,\dots c_n$ egész
      esetén.},
    content/english={TODO}
  }
\end{theorem}

\begin{exercise}
  \Wrap{
    content/magyar={Írj eljárást, amely a kínai maradéktétel megoldását állítja elő. Az
      programnak két lista típusú bemenete legyen, az egyik a kínai maradéktételnél
      szereplő $c$ számok a másik pedig a (páronként relatív prím) modulusok. Ellenőrzéshez
      használható a \texttt{crt} parancs.},
    content/english={TODO}
  }

  \begin{solution}
    \begin{sageexample}
    sage: def chinese(C,M):
    ....:     if len(C) != len(M):
    ....:         return None
    ....:     c, m = C[0], M[0]
    ....:     for i in range(1, len(C)):
    ....:         (g, u, v) = xgcd(m, M[i])
    ....:         if g != 1:
    ....:             return None
    ....:         c = (c*M[i]*v + C[i]*m*u)
    ....:         m *= M[i]
    ....:         c %= m
    ....:     return c
    \end{sageexample}
  \end{solution}
\end{exercise}

\begin{exercise}
  \Wrap{
    content/magyar={Írj eljárást amely lineáris kongruencia-rendszereket old meg! A programnak
      három lista típusu bemenete van: a bal oldalak együtthatóinak, a jobb oldalaknak és a
      modulusoknak listái.},
    content/english={TODO}
  }

  \begin{solution}
    \begin{sageexample}
    sage: def lin_cong_sys(A,B,M):
    ....:     if len(A) != len(B) or len(B) != len(C):
    ....:         return None # should raise some exception
    ....:     c, m = 0, 1
    ....:     for  i in range(len(A)):
    ....:         #sole the ith equation
    ....:         (d, x, _) = xgcd(A[i], M[i])
    ....:         if B[i] % d != 0:
    ....:             return None
    ....:         x = (x*B[i]/d) % M[i]
    ....:         #add to the solution
    ....:         (g, u, v) = xgcd(m, M[i])
    ....:         if (c-x) % g != 0:
    ....:             return None
    ....:         c = (c*M[i]*v + x*m*u)/g
    ....:         m *= M[i]
    ....:         c %= m
    ....:     return c
    \end{sageexample}
  \end{solution}
\end{exercise}

\Wrap{
  content/magyar={A lineáris egyenletek mellett természetesen magasabb rendű és más típusú
    egyenletek is elképzelhetőek. Ezek megoldása általában más problémákat vet fel mint valós
    vagy akár komplex megfelelőjük, de mivel a keresett megoldás egy véges halmazban van, a
    legrosszabb esetben is megkaphatjuk a megoldást végigpróbálva az összes lehetséges értéket.},
  content/english={TODO}
}

\begin{exercise}[\Wrap{content/magyar=Kvardratikus maradékok, content/english=Quadratic residues}]
  \Wrap{
    content/magyar={Írj programot, amely egy adott $m$ esetén megadja azon $b$ $0$ és $m-1$
    közötti számok halmazát, amelyek esetén az \[ x^2 \equiv b\ (m) \] egyenlet megoldható.},
    content/english={TODO}
  }
  \begin{solution}
    \begin{sageexample}
    sage: def quadratic_residues(m):
    ....:     qrs = set()
    ....:     for i in range(m):
    ....:         qrs.add(i^2 % m)
    ....:     return qrs
    \end{sageexample}
  \end{solution}
\end{exercise}

\Wrap{
  content/magyar={Matematikában és az informatikai alkalmazások területén is fontos szerepe van a
    \[ a^x\equiv b\ (m) \] típusú (logaritmushoz hasonló) egyenleteknek. },
  content/english={TODO}
}

\begin{theorem}[(Kis) Fermat-tétel]
  Ha $p$ prím és $a$ tetszőleges egész szám, akkor\[ a^{p-1}\equiv 1\ (p).\]
\end{theorem}

\begin{theorem}[Euler-Fermat-tétel]
  Ha $a$ és $m$ relatív prímek, akkor \[ a^{\varphi(m)}\equiv 1\ (m), \] ahol $\varphi$ az
  Euler-féle $\varphi$ függvény.
\end{theorem}

\begin{definition}[RSA asszimetrikus titkosítás]
  Általában egy asszimetrikus titkosítási sémánál két kulcs áll rendelkezésre (egy publikus és egy
  privát) és a két kucsot egymás után használva visszakapjuk az üzenetet. \emph{RSA} séma esetén
  \begin{itemize}
    \item választunk két elég nagy és megfelelő formájú $p$, $q$ prímet,
    \item egy $e>1$ kitevőt és
    \item számoljuk ki $n=pq$-t, illetve
    \item egy $d$ egész számot, melyre $ed\equiv 1\ (\varphi(n)=(p-1)(q-1))$.
  \end{itemize}
  A publikus kulcs $(n,e)$, a privát kulcs $(n,d)$ lesz és egy $m<n$ szám mint üzenet titkosított
  formáját kapjuk az $s = m^d \mod n$ kiszámolásával. A visszafejtés az Euler-Fermat-tétel
  használatával \[ s^d\equiv (m^d)^e\equiv m^{ed}\equiv m^{\varphi(m)q+1}\equiv m\ (n). \]
\end{definition}

\begin{exercise}
  \Wrap{
    content/magyar={Írj osztályt, amely addott publikus paraméterek esetén megvalósítja a RSA sémát!},
    content/english={TODO}
  }

  \begin{solution}
    \begin{sageexample}
    sage: class RSA(object):
    ....:     #this is just a dummy implementation, not for actual use
    ....:     def __init__(self, length):
    ....:         # uniformly choosen prime is not a good idea in real life
    ....:         p = random_prime(2^(length-2), lbound=2^(length-3))
    ....:         q = random_prime(2^(length+2), lbound=2^(length+1))
    ....:         self.__n = p*q
    ....:         self.__phin = (p-1)*(q-1)
    ....:         self.__e = 3 #should choose this more carefully
    ....:         while gcd(self.__e, self.__phin) != 1:
    ....:             self.__e += 2
    ....:         self.__d = inverse_mod(self.__e, self.__phin)
    ....:     def public_key(self):
    ....:         return (self.__n, self.__e)
    ....:     @staticmethod
    ....:     def encrypt(pubkey, message):
    ....:         return power_mod(message, pubkey[1], pubkey[0])
    ....:     def decrypt(self, secret):
    ....:         return power_mod(secret, self.__d, self.__n)
    \end{sageexample}
  \end{solution}
\end{exercise}

\begin{definition}[Diszkrét logarimus probléma]
  Vegyünk egy $p$ prímet és egy olyan $g$ számot, amely hatványaival modulo $p$ előállítja az
  összes $p$-nél kisebb pozitív számot. Ekkor egy $a$ esetén a $g^a\mod p$ értékből $a$
  meghatározását diszkrét logaritmus problémának hívjuk.
\end{definition}

\begin{definition}[Diffie-Hellman kulcscsere]
  A diszkrét logaritmus problémánál használt $p$ és $g$ publikus paramétereket használva két
  kommunikációs fél (Alice és Bob) tud közös értékben (kulcs) megállapodni Diffie-Hellman
  sémát használva. A séma során mindkét fél választ egy-egy véletlen értéket (titok) és számolják a
  $g^a$ és $g^b$ publikus értékeket. Ezek alapján mindketten ki tudják számolni a közös kulcsot:
  \[g^{ab} = (g^a)^b = (g^b)^a.\]
\end{definition}

\begin{exercise}
  \Wrap{
    content/magyar={Írj programot, amely egy Diffie-Hellman kulcscsere folyamatát szemlélteti.},
    content/english={TODO}
  }

  \begin{solution}
    \begin{sageexample}
    sage: class DH_participant(object):
    ....:     def __init__(self, p, g):
    ....:         self.__p = p
    ....:         self.__g = g
    ....:         self.__x = randint(1, p-1)
    ....:     def get_pub(self):
    ....:         return power_mod(self.__g, self.__x, self.__p)
    ....:     def calculate_common_key(self, pub_of_other):
    ....:         return power_mod(pub_of_other, self.__x, self.__p)
    ....: Alice = DH_participant(65537, 2)
    ....: Bob   = DH_participant(65537, 2)
    ....: #common key
    ....: Alice.calculate_common_key(Bob.get_pub())
    ....: Bob.calculate_common_key(Alice.get_pub())
    \end{sageexample}
  \end{solution}
\end{exercise}

% TODO put the cryptograhpy part in the coding theory as separate section