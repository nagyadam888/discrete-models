r"""
This file was *autogenerated* from lecture_notes.tex with sagetex.sty
version 2019/11/14 v3.4. It contains the contents of all the
sageexample environments from lecture_notes.tex. You should be able to
doctest this file with "sage -t lecture_notes_doctest.sage".

It is always safe to delete this file; it is not used in typesetting your
document.

Sage example, line 11::

    sage: type(ZZ)
  

Sage example, line 25::

    sage: a,b = ZZ(4), 4
    sage: type(a) == type(b)
    sage: a == b
  

Sage example, line 63::

    sage: 2/3
    sage: type(2/3)
    sage: 1/1
    sage: type(1/1)
  

Sage example, line 21::

    sage: def divides0(a,b):
    ....:     return (a/b).is_integer()
    sage: divides0(5,2)
    sage: divides0(6,3)
  

Sage example, line 33::

        sage: def divides0(a,b):
        ....:     return (a/b).is_integer()
        sage: def divides1(a,b):
        ....:     return a % b == 0
        sage: def divides2(a,b):
        ....:     return (a//b)*b == a
        sage: def divides3(a,b):
        ....:     return (a/b).denom() == 1
        sage: def divides4(a,b): #there is room to improve
        ....:     if a == 0:
        ....:         return True
        ....:     b *= sign(b)
        ....:     if b == 1:
        ....:         return True
        ....:     q = b
        ....:     a *= sign(a)
        ....:     while q <= a:
        ....:         q <<= 1
        ....:     while a > b:
        ....:         q >>= 1
        ....:         a -= q
        ....:         a *= sign(a)
        ....:     return a == 0 or a == b

      

Sage example, line 103::

  sage: k = 15
  ....: P = Poset((Set([2..k]), lambda a,b: b % a == 0))

Sage example, line 124::

    sage: len(P.cover_relations_graph().edges())
  

Sage example, line 133::

      sage: def edges_in_div_hasse(S):
      ....:     count = 0
      ....:     L = list(S)
      ....:     L.sort(reverse=True)
      ....:     for i in range(1,len(L)):
      ....:         S = set()
      ....:         for j in range(i-1,-1,-1):
      ....:             if L[j] % L[i] == 0:
      ....:                 direct = True
      ....:                 for k in S:
      ....:                     if L[j] % L[k] == 0:
      ....:                         direct = False
      ....:                         break
      ....:                 if direct:
      ....:                     S.add(j)
      ....:                     count += 1
      ....:     return count
    

Sage example, line 230::

  sage: P1 = plot(x/log(x), (2, 200), scale='semilogy', \
  ....:     fill=lambda x: prime_pi(x),fillcolor='red')
  ....: P2 = plot(1.13*log(x), (2, 200), \
  ....:     fill=lambda x: nth_prime(x)/floor(x), fillcolor='red')
  ....: P = graphics_array([P1, P2])

Sage example, line 26::

      sage: def residue_sets(S,m):
      ....:     rs = {}
      ....:     for e in S:
      ....:         r = e % m
      ....:         if r in rs.keys():
      ....:             rs[r].add(e)
      ....:         else:
      ....:             rs[r] = set([e])
      ....:     return rs
    

Sage example, line 89::

  sage: P  = points([(k,euler_phi(k)) for k in range(1,1001)])

Sage example, line 106::

    # according to the definition
    sage: def ephi_01(m):
    ....:     p = 0
    ....:     for i in range(1,m):
    ....:         p += gcd(i,m) == 1
    ....:     return p

    #according to the previous note
    sage: def ephi_02(m):
    ....:     p = 1
    ....:     for (a,b) in factor(m):
    ....:         p *= a^(b-1)*(a-1)
    ....:     return p

    

Sage example, line 175::

    sage: def lin_cong(a,b,m):
    ....:     (d,x,y) = xgcd(a,m)
    ....:     return x % m/d
    

Sage example, line 199::

    sage: def modinv(a,m):
    ....:     (d,x,y) = xgcd(a,m)
    ....:     if d == 1:
    ....:         return x % m
    ....:     else:
    ....:         return None
    

Sage example, line 283::

    sage: def chinese(C,M):
    ....:     if len(C) != len(M):
    ....:         return None
    ....:     c, m = C[0], M[0]
    ....:     for i in range(1, len(C)):
    ....:         (g, u, v) = xgcd(m, M[i])
    ....:         if g != 1:
    ....:             return None
    ....:         c = (c*M[i]*v + C[i]*m*u)
    ....:         m *= M[i]
    ....:         c %= m
    ....:     return c
    

Sage example, line 309::

    sage: def lin_cong_sys(A,B,M):
    ....:     if len(A) != len(B) or len(B) != len(C):
    ....:         return None # should raise some exception
    ....:     c, m = 0, 1
    ....:     for  i in range(len(A)):
    ....:         #sole the ith equation
    ....:         (d, x, _) = xgcd(A[i], M[i])
    ....:         if B[i] % d != 0:
    ....:             return None
    ....:         x = (x*B[i]/d) % M[i]
    ....:         #add to the solution
    ....:         (g, u, v) = xgcd(m, M[i])
    ....:         if (c-x) % g != 0:
    ....:             return None
    ....:         c = (c*M[i]*v + x*m*u)/g
    ....:         m *= M[i]
    ....:         c %= m
    ....:     return c
    

Sage example, line 347::

    sage: def quadratic_residues(m):
    ....:     qrs = set()
    ....:     for i in range(m):
    ....:         qrs.add(i^2 % m)
    ....:     return qrs
    

Sage example, line 393::

    sage: class RSA(object):
    ....:     #this is just a dummy implementation, not for actual use
    ....:     def __init__(self, length):
    ....:         # uniformly choosen prime is not a good idea in real life
    ....:         p = random_prime(2^(length-2), lbound=2^(length-3))
    ....:         q = random_prime(2^(length+2), lbound=2^(length+1))
    ....:         self.__n = p*q
    ....:         self.__phin = (p-1)*(q-1)
    ....:         self.__e = 3 #should choose this more carefully
    ....:         while gcd(self.__e, self.__phin) != 1:
    ....:             self.__e += 2
    ....:         self.__d = inverse_mod(self.__e, self.__phin)
    ....:     def public_key(self):
    ....:         return (self.__n, self.__e)
    ....:     @staticmethod
    ....:     def encrypt(pubkey, message):
    ....:         return power_mod(message, pubkey[1], pubkey[0])
    ....:     def decrypt(self, secret):
    ....:         return power_mod(secret, self.__d, self.__n)
    

Sage example, line 438::

    sage: class DH_participant(object):
    ....:     def __init__(self, p, g):
    ....:         self.__p = p
    ....:         self.__g = g
    ....:         self.__x = randint(1, p-1)
    ....:     def get_pub(self):
    ....:         return power_mod(self.__g, self.__x, self.__p)
    ....:     def calculate_common_key(self, pub_of_other):
    ....:         return power_mod(pub_of_other, self.__x, self.__p)
    ....: Alice = DH_participant(65537, 2)
    ....: Bob   = DH_participant(65537, 2)
    ....: #common key
    ....: Alice.calculate_common_key(Bob.get_pub())
    ....: Bob.calculate_common_key(Alice.get_pub())
    

Sage example, line 59::

      sage: class my_poly(object):
      ....:     def __init__(self, F):
      ....:         self.__coeffs = F
      ....:     def deg(self):
      ....:         d = len(self.__coeffs)-1
      ....:         while d >= 0 and self.__coeffs[d] == 0:
      ....:             d -= 1
      ....:         if d >= 0:
      ....:             return d
      ....:         return -Infinit
      ....:     def __add__(self, other):
      ....:         L, i = [], 0
      ....:         while i < len(self.__coeffs) and i < len(other.__coeffs):
      ....:             L.append(self.__coeffs[i] + other.__coeffs[i])
      ....:             i += 1
      ....:         while i < len(self.__coeffs):
      ....:             L.append(self.__coeffs[i])
      ....:             i += 1
      ....:         while i < len(other.__coeffs):
      ....:             L.append(other.__coeffs[i])
      ....:             i += 1
      ....:         return my_poly(L)
      ....:     def __mul__(self, other):
      ....:         L, i = [], 0
      ....:         # as the definition goes
      ....:         for i in range(len(self.__coeffs) + len(other.__coeffs)-1):
      ....:             L.append(0)
      ....:             j = max(0, i-len(self.__coeffs)+2)
      ....:             while j <= i and j < len(self.__coeffs):
      ....:                 L[i] += self.__coeffs[j]*other.__coeffs[i-j]
      ....:                 j += 1
      ....:         return my_poly(L)
      ....:     def __repr__(self):
      ....:         return str(self.__coeffs)
    

Sage example, line 125::

      sage: class my_poly2(my_poly):
      ....:     def eval(self, x):
      ....:         y = 0
      ....:         for c in self._my_poly__coeffs:
      ....:             y = x*y + c
      ....:         return y
    

"""
